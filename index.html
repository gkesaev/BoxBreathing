<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Box Breathing</title>
  <meta name="description" content="Box Breathing — a calm 4-4-4-4 breathing exercise with soothing visuals to help relax and focus.">
  <link rel="canonical" href="https://gkesaev.github.io/BoxBreathing/">
  <!-- Open Graph / Social preview -->
  <meta property="og:type" content="website">
  <meta property="og:title" content="Box Breathing">
  <meta property="og:description" content="Practice the 4-4-4-4 box breathing technique with a soothing animated UI to help reduce stress and regain focus.">
  <meta property="og:site_name" content="Box Breathing">
  <meta property="og:url" content="https://gkesaev.github.io/BoxBreathing/">
  <meta property="og:image" content="/og-image.svg">
  <meta property="og:image:width" content="1200">
  <meta property="og:image:height" content="630">
  <style>
    :root{
      --bg-duration-1: 60s;
      --bg-duration-2: 90s;
      --particle-duration-min: 8s;
      --particle-duration-var: 6s;
      --wave-duration-1: 40s;
      --wave-duration-2: 50s;
      --wave-duration-3: 60s;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html, body {
      height: 100svh;
      overflow: hidden;
      overscroll-behavior: none;
    }

    body {
      min-height: 100svh;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background: linear-gradient(135deg, #581c87, #1e3a8a, #0f766e);
      position: relative;
      /* keep the page background filling the full viewport; apply safe-area padding only to the centered container */
      padding: 0;
    }

    /* Animated background overlays - smoothed */
    .background-overlay {
      position: fixed;
      left: -18px;
      top: -18px;
      right: -18px;
      bottom: -18px;
      opacity: 0.9;
      pointer-events: none;
      z-index: 0;
      background-clip: border-box;
    transform: translateZ(0); /* request GPU compositing without subpixel offset */
  -webkit-transform: translateZ(0);
  will-change: transform;
    }

    #particles {
      position: fixed;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      overflow: visible;
    }

    .background-gradient-1,
    .background-gradient-2 {
      position: fixed;
      left: -18px;
      top: -18px;
      right: -18px;
      bottom: -18px;
      mix-blend-mode: screen;
      pointer-events: none;
      z-index: 0;
      backface-visibility: hidden;
      -webkit-backface-visibility: hidden;
  transform: translateZ(0); /* avoid subpixel seam artifacts */
  -webkit-transform: translateZ(0);
  will-change: transform;
      background-size: cover;
    }

    .background-gradient-1 {
      background: linear-gradient(135deg,
        rgba(6,182,212,0.28) 0%,
        rgba(147,51,234,0.28) 50%,
        rgba(236,72,153,0.28) 100%);
      animation:
        hueShift var(--bg-duration-1) linear infinite,
        gradientFloat calc(var(--bg-duration-1) / 2) ease-in-out infinite;
      opacity: 0.85;
    }

    @keyframes hueShift {
      from { filter: hue-rotate(0deg) saturate(1); }
      to   { filter: hue-rotate(360deg) saturate(1); }
    }

    @keyframes gradientFloat {
      0%   { transform: translate3d(-2%, -1%, 0) scale(1); }
      25%  { transform: translate3d(1.5%, -1%, 0) scale(1.02); }
      50%  { transform: translate3d(2%, 1.5%, 0) scale(1); }
      75%  { transform: translate3d(-1.5%, 1%, 0) scale(0.99); }
      100% { transform: translate3d(-2%, -1%, 0) scale(1); }
    }

    .background-gradient-2 {
      background:
        radial-gradient(30% 30% at 20% 50%, rgba(147,51,234,0.35), transparent 40%),
        radial-gradient(28% 28% at 80% 20%, rgba(6,182,212,0.28), transparent 35%),
        radial-gradient(26% 26% at 40% 80%, rgba(236,72,153,0.28), transparent 35%);
      animation: radialDrift var(--bg-duration-2) ease-in-out infinite;
      opacity: 0.9;
    }

    @keyframes radialDrift {
      0% {
        background-position: 20% 50%, 80% 20%, 40% 80%;
        transform: scale(1);
      }
      33% {
        background-position: 30% 30%, 70% 30%, 45% 70%;
        transform: scale(1.01);
      }
      66% {
        background-position: 10% 60%, 85% 10%, 35% 85%;
        transform: scale(0.995);
      }
      100% {
        background-position: 20% 50%, 80% 20%, 40% 80%;
        transform: scale(1);
      }
    }

    /* Floating particles - smoother motion using translate with CSS var offsets */
    .particle {
      position: absolute;
      border-radius: 50%;
      pointer-events: none;
      will-change: transform, opacity;
      animation: floatSmooth calc(var(--particle-duration-min) + var(--particle-duration-var) * var(--rand, 0.5)) ease-in-out infinite;
      opacity: 0;
    }

    @keyframes floatSmooth {
      0% {
        transform: translate3d(0, 0, 0) scale(0.4) translateX(var(--x-offset, 0px));
        opacity: 0;
      }
      10% {
        opacity: .85;
      }
      50% {
        transform: translate3d(var(--x-offset, -70px), -50vh, 0) scale(1.05);
        opacity: .9;
      }
      90% {
        opacity: 0.25;
      }
      100% {
        transform: translate3d(calc(var(--x-offset) * -0.4), -110vh, 0) scale(1.2);
        opacity: 0;
      }
    }

    /* Swirling waves */
    .wave {
      position: fixed;
      width: 120%;
      height: 120%;
      left: -12%;
      top: -12%;
      border-radius: 50%;
      /* avoid will-change on very large elements to reduce compositing memory */
      animation: spin linear infinite;
      opacity: 0.12;
      z-index: 1;
      pointer-events: none;
      backface-visibility: hidden;
    }

    @keyframes spin {
      0% {
        transform: rotate(0deg) scale(1);
        opacity: 0.08;
      }
      50% {
        transform: rotate(180deg) scale(1.06);
        opacity: 0.25;
      }
      100% {
        transform: rotate(360deg) scale(1);
        opacity: 0.08;
      }
    }

    /* Main content */
    .container {
      position: relative;
      z-index: 10;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 100%;
      height: 100svh;
      padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
      box-sizing: border-box;
    }

    .square-container {
      width: min(92vw, 520px);
      max-height: calc(100svh - 4rem);
      aspect-ratio: 1 / 1; /* always keep square */
      height: auto;
      position: relative;
      opacity: 0;
      animation: fadeIn 1s ease-out forwards;
      touch-action: manipulation;
      display: block;
      transform-origin: center center; /* keep breathing scale centered */
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: scale(0.8); }
      to { opacity: 1; transform: scale(1); }
    }

    /* Breathing animation states */
    .square-container.breathing {
      transition: transform 4s linear;
    }

    .square-container.inhale {
      transform: scale(1.15);
    }

    .square-container.hold-full {
      transform: scale(1.15);
    }

    .square-container.exhale {
      transform: scale(1);
    }

    .square-container.hold-empty {
      transform: scale(1);
    }

    /* Square border */
    .square {
      width: 100%;
      height: 100%;
      border: 16px solid white;
      box-sizing: border-box;
      background: rgba(30, 59, 138, 0.1);
      box-shadow: 0 0 30px rgba(255, 255, 255, 0.8), 0 0 60px rgba(255, 255, 255, 0.6);
      animation: glowPulse 5s ease-in-out infinite;
      position: relative;
    }

    @keyframes glowPulse {
      0%, 100% { box-shadow: 0 0 30px rgba(255, 255, 255, 0.8), 0 0 60px rgba(255, 255, 255, 0.6); }
      50% { box-shadow: 0 0 40px rgba(255, 255, 255, 1), 0 0 80px rgba(255, 255, 255, 0.8); }
    }

    /* Breathing dot: size controlled by CSS var set from JS for perfect scaling */
    .dot {
      position: absolute;
      width: var(--dot-size, 34px);
      height: var(--dot-size, 34px);
      background: #FF2D9E;
      border-radius: 50%;
      box-shadow: 0 0 30px rgba(255, 45, 158, 0.9), 0 0 60px rgba(255, 45, 158, 0.6);
      animation: dotPulse 2.5s ease-in-out infinite;
      display: none;
      z-index: 20;
      transform: translate(-50%, -50%);
      /* We'll control promotion to a composited layer only when needed via .promote-transform */
    }

    /* Small helper class: enable layer promotion only briefly when we need smooth movement */
    .promote-transform { will-change: transform; }

    @keyframes dotPulse {
      0%, 100% { transform: translate(-50%, -50%) scale(1); opacity: 0.85; }
      50% { transform: translate(-50%, -50%) scale(1.12); opacity: 1; }
    }

    .dot.active {
      display: block;
    }

    /* Center content */
    .center-content {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      z-index: 10;
    }

    /* Fluid typography for mobile */
    .instruction {
      font-size: clamp(1.25rem, 4.4vw, 2.25rem);
      font-weight: 300;
      color: white;
      text-shadow: 0 0 20px rgba(255, 255, 255, 1), 0 0 40px rgba(255, 255, 255, 0.8);
      margin-bottom: 0.5rem;
    }

    .countdown-number {
      font-size: clamp(2rem, 9vw, 3.75rem);
      font-weight: 300;
      color: white;
      text-shadow: 0 0 25px rgba(255, 255, 255, 1), 0 0 50px rgba(255, 255, 255, 0.8);
      margin: 0.5rem 0;
    }

    .round-info {
      font-size: 0.875rem;
      color: rgba(255, 255, 255, 0.8);
      text-shadow: 0 0 10px rgba(255, 255, 255, 0.8);
      margin-top: 0.5rem;
    }

    /* Button */
    .btn {
      padding: clamp(0.9rem, 2.8vw, 1.5rem) clamp(1.6rem, 6vw, 3rem);
      background: linear-gradient(to right, #06b6d4, #9333ea);
      color: white;
      border: none;
      border-radius: 9999px;
      font-size: clamp(0.95rem, 3.2vw, 1rem);
      font-weight: 500;
      cursor: pointer;
      box-shadow: 0 0 30px rgba(6, 182, 212, 0.3);
      transition: all 0.3s ease;
    }

    #startBtn {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 10;
      animation: fadeInUp 1s ease-out 0.5s forwards;
      opacity: 0;
    }

    @keyframes fadeInUp {
      from { opacity: 0; transform: translate(-50%, -50%) scale(0.9); }
      to { opacity: 1; transform: translate(-50%, -50%) scale(1); }
    }

    #startBtn:hover {
      transform: translate(-50%, -50%) scale(1.05);
      box-shadow: 0 0 40px rgba(6, 182, 212, 0.5);
      background: linear-gradient(to right, #0891b2, #7e22ce);
    }

    #startBtn:active {
      transform: translate(-50%, -50%) scale(0.98);
    }

    .btn:hover {
      transform: scale(1.05);
      box-shadow: 0 0 40px rgba(6, 182, 212, 0.5);
      background: linear-gradient(to right, #0891b2, #7e22ce);
    }

    .btn:active {
      transform: scale(0.98);
    }

    .hidden {
      display: none;
    }

    /* Completion state */
    .completion {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      z-index: 15;
      pointer-events: none;
    }

    .completion:not(.hidden) {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 1.5rem;
      animation: completionFadeIn 1s ease-out forwards;
    }

    .completion .btn {
      position: static;
      pointer-events: auto;
    }

    @keyframes completionFadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    .completion-emoji {
      font-size: 3.75rem;
      animation: emojiPulse 3s ease-in-out infinite;
    }

    @keyframes emojiPulse {
      0%, 100% { transform: scale(1); opacity: 0.7; }
      50% { transform: scale(1.1); opacity: 1; }
    }

    .completion-title {
      font-size: 1.875rem;
      font-weight: 300;
      color: rgb(165, 243, 252);
      text-shadow: 0 0 10px rgba(6, 182, 212, 0.5);
      text-align: center;
    }

    .completion-text {
      color: rgba(165, 243, 252, 0.8);
      line-height: 1.625;
      text-align: center;
    }

    /* Initial countdown styles */
    .initial-countdown {
      font-size: 3.75rem;
      font-weight: 300;
      color: white;
      text-shadow: 0 0 30px rgba(255, 255, 255, 1), 0 0 60px rgba(255, 255, 255, 0.8);
      animation: countdownPop 0.6s ease-out;
    }

    @keyframes countdownPop {
      0% { transform: scale(0.5); opacity: 0; }
      50% { transform: scale(1.1); }
      100% { transform: scale(1); opacity: 1; }
    }

    @media (max-width: 420px) {
      .background-gradient-1, .background-gradient-2 { opacity: 0.7; }
      .wave { opacity: 0.06; }
      .square { border-width: 12px; }
    }

    @media (prefers-reduced-motion: reduce) {
      .background-gradient-1,
      .background-gradient-2,
      .particle,
      .wave,
      .dot {
        animation: none !important;
        transition: none !important;
      }
    }

    /* Info button (bottom-right) and modal styles */
    .info-btn {
      position: fixed;
      right: 1rem;
      bottom: 1rem;
      z-index: 30;
      width: 48px;
      height: 48px;
      border-radius: 50%;
      border: none;
      background: linear-gradient(135deg,#06b6d4,#9333ea);
      color: white;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 6px 18px rgba(0,0,0,0.25);
      cursor: pointer;
      transition: transform .18s ease, box-shadow .18s ease;
    }
    .info-btn:focus { outline: 3px solid rgba(165,243,252,0.35); outline-offset: 3px; }
    .info-btn:hover { transform: translateY(-3px); box-shadow: 0 10px 24px rgba(0,0,0,0.3); }

    .info-modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.45);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 40;
      padding: 1.25rem;
    }
    .info-modal-overlay.open { display: flex; }

    .info-modal {
      background: linear-gradient(180deg, rgba(8,10,25,0.95), rgba(10,14,32,0.92));
      color: #e6f7fb;
      max-width: 680px;
      width: 100%;
      border-radius: 12px;
      padding: 1.25rem 1.5rem;
      box-shadow: 0 20px 60px rgba(4,7,25,0.6);
      max-height: 84vh;
      overflow: auto;
      -webkit-overflow-scrolling: touch;
    }

    .info-modal h3 { margin-bottom: 0.5rem; font-weight: 600; color: #c7f9ff; }
    .info-modal p { color: rgba(231, 250, 253, 0.92); line-height: 1.5; margin-bottom: 0.75rem; }
    .info-modal .actions { display:flex; gap:0.5rem; justify-content:flex-end; margin-top:0.5rem; }
    .info-modal .close-btn {
      background: transparent;
      color: #d9faff;
      border: 1px solid rgba(217,250,255,0.08);
      padding: 0.5rem 0.75rem;
      border-radius: 8px;
      cursor: pointer;
    }
    @media (prefers-reduced-motion: reduce) {
      .info-btn, .info-modal, .info-modal-overlay { transition: none !important; }
    }
  </style>
</head>
<body>
  <!-- Background effects -->
  <div class="background-overlay">
    <div class="background-gradient-1"></div>
    <div class="background-gradient-2"></div>
  </div>

  <!-- Particles (positioned absolutely and not contributing to layout) -->
  <div id="particles"></div>

  <!-- Waves -->
  <div class="wave" style="background: conic-gradient(from 0deg, transparent, rgba(147, 51, 234, 0.2), transparent);"></div>
  <div class="wave" style="background: conic-gradient(from 120deg, transparent, rgba(6, 182, 212, 0.2), transparent); animation-duration: 50s;"></div>
  <div class="wave" style="background: conic-gradient(from 240deg, transparent, rgba(236, 72, 153, 0.2), transparent); animation-duration: 60s;"></div>

  <!-- Main content -->
  <div class="container">
    <div class="square-container">
      <div class="square">
        <div class="center-content" id="centerContent"></div>
        <button class="btn" id="startBtn">Start</button>
        <div class="completion hidden" id="completion">
          <div class="completion-emoji">✨</div>
          <h2 class="completion-title">Well done</h2>
          <p class="completion-text">Take a moment to notice how you feel.</p>
          <button class="btn" id="restartBtn">Restart</button>
        </div>
      </div>
      <div class="dot" id="dot"></div>
    </div>
  </div>

  <!-- Info button (opens explanation modal) -->
  <button id="infoBtn" class="info-btn" aria-label="About box breathing" aria-haspopup="dialog" aria-controls="infoModal" aria-expanded="false">
    ?
  </button>

  <!-- Explanation modal -->
  <div id="infoModalOverlay" class="info-modal-overlay" role="presentation">
    <div id="infoModal" class="info-modal" role="dialog" aria-modal="true" aria-labelledby="infoTitle" tabindex="-1">
      <h3 id="infoTitle">What is box breathing and why it helps</h3>
      <p>Box breathing is a simple, evidence-backed breathing technique: inhale for 4 seconds, hold for 4, exhale for 4, hold for 4. Repeating this cycle helps activate the parasympathetic nervous system, which can lower heart rate and reduce stress.</p>
      <p>Regular practice can improve calmness, focus, and emotional regulation. It's safe, easy to do anywhere, and can be combined with mindfulness to deepen benefits.</p>
      <p>How to try it: Sit comfortably, follow the 4-4-4-4 pattern with slow, even breaths, and repeat for a few minutes. Stop if you feel lightheaded.</p>
      <div class="actions">
        <button id="closeInfoBtn" class="close-btn">Close</button>
      </div>
    </div>
  </div>

  <script>
    // Responsive layout: compute sizes from DOM instead of fixed constants
    let SQUARE_SIZE = 500;
    let BORDER = 16;
    let DOT_SIZE = 34;
    let DOT_RADIUS = DOT_SIZE / 2;
    let INNER_SIZE = SQUARE_SIZE - 2 * BORDER;
    const SIDE_DURATION = 4000;
    const TOTAL_ROUNDS = 3;
    const BREATHING_INSTRUCTIONS = ['Inhale', 'Hold', 'Exhale', 'Hold'];

    let state = 'idle';
    let countdown = 3;
    let currentRound = 0;
    let currentSide = 0;
    let animationFrame = null;
    let animationStartTime = null; // timestamp (ms) when the current side animation started
    let isBreathing = false; // true while the breathing animation is running

    const dot = document.getElementById('dot');
    const centerContent = document.getElementById('centerContent');
    const startBtn = document.getElementById('startBtn');
    const completion = document.getElementById('completion');
    const restartBtn = document.getElementById('restartBtn');
    const squareContainer = document.querySelector('.square-container');
    const squareEl = document.querySelector('.square');

    // Create particles (count adjusts for small screens)
    const particlesContainer = document.getElementById('particles');
    const colors = ['rgba(165, 243, 252, 0.4)', 'rgba(196, 181, 253, 0.4)', 'rgba(251, 207, 232, 0.4)'];
    function createParticles() {
      // Skip creating particles on very small screens to avoid unnecessary DOM work
      const small = window.innerWidth <= 420;
      if (small) {
        particlesContainer.innerHTML = ''; // ensure empty
        return;
      }
      particlesContainer.innerHTML = '';
      const count = 20;
      for (let i = 0; i < count; i++) {
        const particle = document.createElement('div');
        particle.className = 'particle';
        particle.style.cssText = `
          width: ${Math.random() * 3 + 1}px;
          height: ${Math.random() * 3 + 1}px;
          left: ${5 + Math.random() * 90}%;
          top: 110%;
          background: ${colors[i % colors.length]};
          --x-offset: ${Math.random() * 120 - 60}px;
          animation-delay: ${Math.random() * 10}s;
          animation-duration: ${8 + Math.random() * 6}s;
        `;
        particlesContainer.appendChild(particle);
      }
    }
    createParticles();

    // Compute layout variables from DOM so the dot tracks the responsive square
    function updateLayoutVariables() {
      // Use the actual .square element for precise size (includes border)
      const rect = squareEl.getBoundingClientRect();
      const containerRect = squareContainer.getBoundingClientRect();
      SQUARE_SIZE = Math.round(Math.min(rect.width, rect.height));
      // read border from computed style of square
      const computed = getComputedStyle(squareEl);
      BORDER = parseFloat(computed.borderWidth) || 16;
      // dot size scales with container (approx 6.8% of square)
      DOT_SIZE = Math.max(18, Math.round(SQUARE_SIZE * 0.068));
      DOT_RADIUS = DOT_SIZE / 2;
      // inner size is the area inside the border
      INNER_SIZE = Math.max(0, SQUARE_SIZE - 2 * BORDER);
      // store offsets so we can position the dot relative to the square inside the container
      squareContainer._squareOffset = {
        left: Math.round(rect.left - containerRect.left),
        top: Math.round(rect.top - containerRect.top)
      };
      // expose dot size to CSS so visuals match JS positions
      squareContainer.style.setProperty('--dot-size', DOT_SIZE + 'px');
    }

  // Initial layout compute (run after DOM is parsed)
  document.addEventListener('DOMContentLoaded', () => updateLayoutVariables());

    // Keep layout variables updated on resize/orientation; use a debounced resize handler
    let resizeTimer = null;
    function onResize() {
      if (resizeTimer) clearTimeout(resizeTimer);
      resizeTimer = setTimeout(() => {
        updateLayoutVariables();
        createParticles();
        // reposition dot to current state so it doesn't jump.
        // Use the real animation start time/progress when available instead of Date.now() % SIDE_DURATION
        if (isBreathing && animationStartTime) {
          const progress = Math.max(0, Math.min(1, (Date.now() - animationStartTime) / SIDE_DURATION));
          updateDotPosition(currentSide, progress);
        } else if (animationStartTime) {
          // If we have a start time but not flagged breathing (edge case), still compute a clamped progress
          const progress = Math.max(0, Math.min(1, (Date.now() - animationStartTime) / SIDE_DURATION));
          updateDotPosition(currentSide, progress);
        } else {
          // fallback: place dot at beginning of current side
          updateDotPosition(currentSide, 0);
        }
      }, 120);
    }
    window.addEventListener('resize', onResize);
    window.addEventListener('orientationchange', onResize);

    function getDotPosition(side, progress) {
      // progress: 0..1 along side
      // compute span along the center-line of the border stroke
      const strokeCenter = BORDER / 2; // center of the border stroke
      const span = Math.max(0, SQUARE_SIZE - BORDER); // distance between left stroke-center and right stroke-center

      switch (side) {
        case 0: // top edge left -> right
          return { x: strokeCenter + progress * span, y: strokeCenter };
        case 1: // right edge top -> bottom
          return { x: strokeCenter + span, y: strokeCenter + progress * span };
        case 2: // bottom edge right -> left
          return { x: strokeCenter + span - progress * span, y: strokeCenter + span };
        case 3: // left edge bottom -> top
          return { x: strokeCenter, y: strokeCenter + span - progress * span };
        default:
          return { x: strokeCenter, y: strokeCenter };
      }
    }

    function updateDotPosition(side, progress) {
      const pos = getDotPosition(side, progress);
      // position relative to the .square within .square-container
      const offset = squareContainer._squareOffset || { left: 0, top: 0 };
      // Use transform for GPU-friendly movement: set a base left/top (pixel aligned) and apply translate for animation
      const left = Math.round(offset.left + pos.x);
      const top = Math.round(offset.top + pos.y);
      dot.style.left = `${left}px`;
      dot.style.top = `${top}px`;
      dot.style.transform = 'translate(-50%, -50%)';
    }

    function startInitialCountdown() {
      state = 'countdown';
      startBtn.classList.add('hidden');
      countdown = 3;

      function countdownTick() {
        if (countdown > 0) {
          centerContent.innerHTML = `<div class="initial-countdown">${countdown}</div>`;
          countdown--;
          setTimeout(countdownTick, 800);
        } else {
          startBreathing();
        }
      }
      countdownTick();
    }

    function startBreathing() {
      updateLayoutVariables();
      state = 'breathing';
      currentRound = 1;
      currentSide = 0;
      dot.classList.add('active');

      animateBreathing();
    }

    function updateSquareBreathing(side) {
      squareContainer.classList.remove('inhale', 'hold-full', 'exhale', 'hold-empty');
      squareContainer.classList.add('breathing');

      switch(side) {
        case 0:
          squareContainer.classList.add('inhale');
          break;
        case 1:
          squareContainer.classList.add('hold-full');
          break;
        case 2:
          squareContainer.classList.add('exhale');
          break;
        case 3:
          squareContainer.classList.add('hold-empty');
          break;
      }
    }

    function animateBreathing() {
      // mark that breathing is active and remember when this side started
      isBreathing = true;
      const startTime = Date.now();
      animationStartTime = startTime;
      updateSquareBreathing(currentSide);
      dot.classList.add('promote-transform');
      // remove the promotion after a small delay (allow browser to establish the layer)
      const promoteTimeout = setTimeout(() => dot.classList.remove('promote-transform'), 650);

      function update() {
        if (state !== 'breathing') return;

  const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / SIDE_DURATION, 1);
        const sideCountdown = Math.max(1, 4 - Math.floor(progress * 4));

        updateDotPosition(currentSide, progress);

        centerContent.innerHTML = `
          <div>
            <h2 class="instruction">${BREATHING_INSTRUCTIONS[currentSide]}</h2>
            <div class="countdown-number">${sideCountdown}</div>
            <p class="round-info">Round ${currentRound} of ${TOTAL_ROUNDS}</p>
          </div>
        `;

        if (elapsed >= SIDE_DURATION) {
          const nextSide = (currentSide + 1) % 4;
          const nextRound = nextSide === 0 ? currentRound + 1 : currentRound;

          if (nextRound > TOTAL_ROUNDS) {
            showCompletion();
            return;
          }

          currentSide = nextSide;
          currentRound = nextRound;
          // start next side: update animationStartTime so onResize and reposition use correct base
          animationStartTime = Date.now();
          // ensure we clear any pending promotion timeout (if any)
          clearTimeout(promoteTimeout);
          animateBreathing();
          return;
        }

        animationFrame = requestAnimationFrame(update);
      }

      update();
    }

    function showCompletion() {
      state = 'complete';
      // clear animation state
      isBreathing = false;
      animationStartTime = null;
      dot.classList.remove('active');
      centerContent.innerHTML = '';
      completion.classList.remove('hidden');
      squareContainer.classList.remove('breathing', 'inhale', 'hold-full', 'exhale', 'hold-empty');
    }

    function restart() {
      state = 'idle';
      // clear animation state
      isBreathing = false;
      animationStartTime = null;
      currentRound = 0;
      currentSide = 0;
      dot.classList.remove('active');
      centerContent.innerHTML = '';
      completion.classList.add('hidden');
      startBtn.classList.remove('hidden');
      squareContainer.classList.remove('breathing', 'inhale', 'hold-full', 'exhale', 'hold-empty');
      if (animationFrame) {
        cancelAnimationFrame(animationFrame);
      }
    }

    startBtn.addEventListener('click', startInitialCountdown);
    restartBtn.addEventListener('click', restart);

    // Recompute layout when page loads (some mobile browsers need a tick)
    window.addEventListener('load', () => {
      // a small timeout helps on iOS/Android where chrome UI affects layout
      setTimeout(() => {
        updateLayoutVariables();
        // ensure dot starts off at the beginning corner
        updateDotPosition(0, 0);
      }, 60);
    });

    // Info modal behavior: accessible open/close, Esc to close, click outside to close, basic focus trap
    (function () {
      const infoBtn = document.getElementById('infoBtn');
      const overlay = document.getElementById('infoModalOverlay');
      const modal = document.getElementById('infoModal');
      const closeBtn = document.getElementById('closeInfoBtn');
      let lastFocused = null;

      function getFocusable() {
        return modal.querySelectorAll('a, button, textarea, input, select, [tabindex]:not([tabindex="-1"])');
      }

      function openModal() {
        lastFocused = document.activeElement;
        overlay.classList.add('open');
        infoBtn.setAttribute('aria-expanded', 'true');
        modal.focus();
        document.addEventListener('keydown', onKeyDown);
      }

      function closeModal() {
        overlay.classList.remove('open');
        infoBtn.setAttribute('aria-expanded', 'false');
        if (lastFocused && typeof lastFocused.focus === 'function') lastFocused.focus();
        document.removeEventListener('keydown', onKeyDown);
      }

      function onKeyDown(e) {
        if (e.key === 'Escape') { closeModal(); return; }
        if (e.key === 'Tab') {
          const focusables = Array.from(getFocusable());
          if (focusables.length === 0) { e.preventDefault(); return; }
          const first = focusables[0];
          const last = focusables[focusables.length - 1];
          if (e.shiftKey && document.activeElement === first) { e.preventDefault(); last.focus(); }
          else if (!e.shiftKey && document.activeElement === last) { e.preventDefault(); first.focus(); }
        }
      }

      overlay.addEventListener('click', (ev) => {
        if (ev.target === overlay) closeModal();
      });
      infoBtn.addEventListener('click', openModal);
      closeBtn.addEventListener('click', closeModal);
      // allow keyboard opening (Enter/Space)
      infoBtn.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); openModal(); }
      });
    }());
  </script>
</body>
</html>
